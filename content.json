{"meta":{"title":"linlin1195 | 博客","subtitle":"linlin的小站","description":"","author":"linyunxiang","url":"https://linlin1195.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2025-05-04T12:43:46.039Z","updated":"2025-05-04T12:43:46.039Z","comments":true,"path":"categories/index.html","permalink":"https://linlin1195.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-07-03T06:20:43.672Z","updated":"2025-07-03T06:20:43.672Z","comments":true,"path":"tags/index.html","permalink":"https://linlin1195.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2024-10-04T02:19:33.000Z","updated":"2025-05-05T05:16:01.346Z","comments":true,"path":"about/index.html","permalink":"https://linlin1195.github.io/about/index.html","excerpt":"","text":"自我介绍 网站首页洛谷 hydro github 我的目标 2025-06 GESP六级 60+ 洛谷 橙名 2026 CSP-J/S 四级勾)以上 完成 LinOS 7"},{"title":"本站更新日志","date":"2025-05-10T16:00:00.000Z","updated":"2025-07-03T06:19:22.890Z","comments":true,"path":"update/index.html","permalink":"https://linlin1195.github.io/update/index.html","excerpt":"","text":"当前版本号： V25.05.10 2024年2024-10-04 本站成立，版本号更新为V1.0。 2024-10-05 第1个有实际内容的帖子诞生，版本号更新为V1.1。 2024-10-06 添加评论功能，版本号更新为V1.2。 2024-10-11 添加密码功能，版本号更新为V1.3。 2025年2025-05-01 停止休眠期，确认以volantis作为站点主题，修改版本号命名规则，版本号设置为V25.05.1(V+年+月+更新编号)。 2025-05-05 修改 本站公约|Site’s Rule ，大规模修改帖子，删除无用、重复、无意义帖子，对一些帖子内容进行修改，并为站点修改域名为blog.linyunxiang.cn，版本号更新为V25.05.2。 2025-05-07 修改上方导航栏文字，增添暗黑模式，修改主页分类文字，版本号更新为V25.05.3。 2025-05-07 域名重回linlin1195.github.io，版本号更新为V25.05.4 2025-05-08 添加主站右侧”站点信息”功能，本站总字数破1k，版本号更新为V25.05.5。 2025-05-08 添加右键菜单功能，版本号更新为V25.05.6。 2025-05-11 添加首页雪花飘落样式，添加更新日志帖，版本号更新为V25.05.7。 2025-05-11 修改右键菜单，更改鼠标样式，版本号更新为V25.05.8。 2025-05-13 主页文章摘要下方显示作者，版本号更新为V25.05.9。 2025-05-13 文章页面增添“更新时间”，版本号更新为V25.05.10"},{"title":"Globe Bintree Studio 团队","date":"2024-10-04T02:19:33.000Z","updated":"2025-05-04T12:45:47.192Z","comments":true,"path":"gbs/index.html","permalink":"https://linlin1195.github.io/gbs/index.html","excerpt":"","text":"Globe Bintree Studio 洛谷正式地址 Globe Bintree Studio 团队公告一、关于GBSGBS是一个综合性的集团。其中GBS(原GB,BDT)旨在为开发者们提供一个舒适、融洽、工作高效的环境。 成员应正确学习使用Markdown和KaTeX。 本团严禁出现任何与侵犯版权有关的事故！本团作品已注册GPL v2.0协议，若发现有人侵犯本团版权，将会予以警告并责令删除。否则将可能上交法庭。 团长：@ttcandy 管理员：@fzt123F 管理员：@blue_peace 管理员：@linyunxiang1111 只有上述人员才能更改公告。 临时成员：分在非普通成员和管理组的人均为临时成员。 标准项目管理 项目名称 最新的Release 最新版 Minecraft Forev(开源) 无Release 未上传 LinOS (个人闭源) 无Release 25H2(V0.9.2.20241124_Beta) ToolsOS(GPLv2.0，封存) 无Release V0.4.4.20240801_RC VS2(GPLv2.0) 无Release V2.1.4.20240730_Alpha PhirgOS(GPLv2.0，封存) 无Release 未上传 GBDT_CMD 无Release 未开始 如果更新了项目管理表，请删除以前的版本并上传新版本。如果是闭源，上传exe可执行文件。否则，上传cpp源文件。注意，如果有Release，则需要同时上传最新的Release版和最新测试版。Beta以下级别不能公开发布。 上传文件格式：[projectname]_[version].exe 或 [projectname]_[version].cpp 版本号格式这样定义：1V1.0.1.20240731_Alpha 解读： 第一位：版本前缀 Preffix V （Version）英文单词“版本”的缩写。 第二位：主版本号 Major Version 当功能模块有较大的变动，比如增加模块或是整体架构发生变化。此版本号由团长决定是否修改。注意：如果当前主版本号已经发布了一个Release，那么也要修改，要确保每个主版本号都有一个Release。并且，修改后，版本从x.0.1开始。 第三位：副版本号 Minor Version 当功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由团长决定是否修改。 第四位：修订版本号 Revision 一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的 Bug 即可发布一个修订版。此版本号由开发人员决定是否修改。 日期：日期版本号 Date 用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。 后缀：希腊字母版本号 Greek Version 希腊字母版本号共有五种，分别为Base、Alpha(α)、Beta(β) 、RC/Gamma(γ) 、 Release Base： 此版本表示该软件仅仅是一个假页面，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是做为整体的一个基础架构。 Alpha(α)： 内测版。这是最早的版本，这个版本包含很多Bug，功能不全，主要给开发和测试人员测试和找 Bug 用。 特点：内测版，Bug多，不稳定，内部版本，不断添加新功能 Beta(β)： 公开测试版。这个版本比 Alpha(α) 版发布得晚一些，主要是给社区用户和忠实用户测试用的，该版本仍然存在很多Bug，但是相对Alpha(α) 版要稳定一些，这个阶段版本的软件还会不断增加新功能。 特点：公测版，不稳定(比 Alpha(α) 版稳定一些)，Bug相对较多，不断添加新功能 RC/Gamma(γ)： 现在大部分人都叫 RC 版（Release Candidate - 候选版本），该版本又较 Beta(β) 版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似预览版，这个发布就标明离最终发行版不远了。 特点：候选版，经过多个 Beta(β) 版本逐渐稳定，基本不添加新功能，修复完Bug即可进入正式发布版。 Release： 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式的版本，是最终交付用户使用的一个版本。该版本有时也称标准版。 特点:正式版，稳定，Bug很少，推荐生产使用 从Base到Release： 新建Base版，把新增功能的框架打好。 改为Alpha版，修复严重Bug，并且不发布。 Alpha改成Beta，并且逐渐修复明显Bug以及添加新功能。（注：Beta需要发布很多版才能保证较稳定） Beta版没有明显Bug了，改为RC版，挂在文件上一周。 RC版大家都要一起测Bug，助力Release降临。 全部修复并且测不出Bug时，你就收获了一个宝贵的Release! 比赛详见 此处 文件抽卡游戏 斗破苍穹全启动器 飞机大战1.0版本 井字棋游戏 迷宫 能量1.0.5 (未完待续)本帖可以评论"},{"title":"","date":"2024-11-24T11:10:32.733Z","updated":"2024-11-24T11:09:52.400Z","comments":true,"path":"wenjian/BDT对于所有成员的规定.html","permalink":"https://linlin1195.github.io/wenjian/BDT%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E6%88%90%E5%91%98%E7%9A%84%E8%A7%84%E5%AE%9A.html","excerpt":"","text":"对所有成员的制度\\raise is only supported in math mode\\textup{\\textmd{注：本文全文运用 \\LaTeX 渲染。}} 旨在为业余开发者们营造一个舒适、友好、高效的开发环境。下面是基础制度： 一、备注和分组自开始，所有人的备注变成了团内工号。其中： 开头为管理组 开头为普通成员 开头为实习成员 开头为待开除成员 开头为前科成员 开头为封禁成员 开头为未知成员 所有人未经允许不得更改其备注。 二、普通规章制度发言$\\textup{\\textmd{BDT 严禁成员出现在团队讨论区等公开发言区域、私信区域出现}}\\textup{\\textbf{辱骂}}\\textup{\\textmd{、}}\\textup{\\textbf{骚扰}}\\textup{\\textmd{、}}\\textup{\\textbf{发布无意义内容}}\\textup{\\textmd{等行为。}}\\textup{\\textmd{如若发现，第一次处以警告并减分（256 分以上，1024 分以下），}}\\textup{\\textmd{第二次则取消管理员职务（若有）并禁言，}}\\textup{\\textmd{第三次直接开除！}}\\textup{\\textmd{不能使用道具抵挡。}}\\textup{\\textbf{※ 禁言，是指进入封禁成员组并禁止其一切发言行为。如果违反可以直接被移出团队。}}$ 开发是一个开源团队。故除、和可以开发闭源项目，$\\textup{\\textmd{其余成员必须开发源代码文件实质内容大小（单位：KB）}}\\ge\\textup{\\textmd{ 7 KB 的项目。}}\\textup{\\textbf{※ 项目，指的是可以持续更新的大型程序，代码量一般在 500 行以上。}}\\textup{\\textbf{※ 作品，指的是轻量级的、代码含量少的程序，代码量一般在 350 行左右。}}$ 若发现有不在上方允许闭源名单内的成员发布闭源作品，将会令其撤下可执行文件，上传源代码文件。拒不开源的，则会手动删除，并移至封禁成员组。※如果代码很复杂或代码量很大，可以申请闭源，我们会酌情处理。 版权严禁出现与版权有关的事故！所有作品均已注册协议！ 对内：如果出现代码雷同或界面以及功能几乎完全相同，则会考虑为抄袭。由团长自行决定如何处罚。 对外：如果出现抄袭，则会责令删除，否则将会举报，进一步将依法处置！ 三、对特定分组成员的制度管理组所有成员不受除团长和副团以外人的管理，但可以把发现的情况上报。团长和副团有权力进行一切操作，但是副团和团长相互制约。 普通和实习成员普通成员无需多言。 实习成员如果发现有违反规则的，情节轻者会警告，情节重者直接开除。 待开除成员表现良好会重新回到普通成员组。如果再次违规则会被开除。 前科成员如果再次违规则会被开除。 封禁成员临时封禁的成员会在处罚期满后进入前科成员组。如果再处罚期再次违规可直接开除。"}],"posts":[{"title":"解密-题面.md","slug":"解密-题面","date":"2025-07-03T06:28:10.000Z","updated":"2025-07-03T06:38:15.316Z","comments":true,"path":"2025/07/03/解密-题面/","permalink":"https://linlin1195.github.io/2025/07/03/%E8%A7%A3%E5%AF%86-%E9%A2%98%E9%9D%A2/","excerpt":"","text":"午夜图书馆 如果你已经知道了答案，前往()填入你的答案检验是否正确。 在城市的边缘，有一座几乎被遗忘的图书馆，名叫“艾尔文纪念图书馆”。它建于上世纪三十年代，曾是知识与智慧的殿堂。然而几十年后，随着电子书籍和网络信息的兴起，这里逐渐被人冷落。直到某天深夜，一位名叫伊森的年轻人无意间走进了这栋建筑。 那天，乌云遮蔽了月亮，风在街角低语。伊森本想去附近的咖啡馆，却被一场突如其来的雨困住，误打误撞地躲进了这座破旧的图书馆。他推开门，一股陈旧纸张混合木头的味道扑面而来。大厅中央是一张巨大的圆形桌子，桌上摆着一本厚重的书，封面已经模糊不清。 伊森翻开了第一页，上面写着：“欢迎来到时间的尽头。” 他继续翻阅，发现这本书似乎不是普通的藏书，而像是一本日志，记录着一个神秘人物的思考与实验。每一页都充满哲学意味，同时又夹杂着看似无意义的数字与符号。例如： “7月3日，星期四，晴。我终于找到了那个公式——它不在纸上，而在镜中。” “时间不是线性的，而是螺旋的。如果你站在第七圈，就能看到第一圈的影子。” “钥匙是‘沉默’，但门需要用声音打开。” 伊森意识到，这些话可能不仅仅是日记，而是一种指引。他继续往下读，试图拼凑出一个完整的线索图。 在书的最后几页，他看到了一段话： “当钟声敲响十二下时，真理将浮现。记住，答案不是你说什么，而是你怎么说。” 突然，图书馆的灯光闪烁了一下，随后全部熄灭。伊森感到一阵寒意袭来，但他没有离开，而是继续寻找线索。他在一张老式木椅下发现了一张泛黄的卡片，上面写着： “你已经知道答案了，只是还没意识到。” 他回到那本书前，再次仔细阅读那些句子。他开始注意到一些细节：某些词语重复出现，有些句子结构奇怪，甚至像是故意安排的某种提示。 伊森闭上眼睛，深吸一口气，又把他呼了出来。 刹那间，书桌上的那本书发出了微弱的光芒，一道暗门缓缓开启…… 故事结束了，你知道伊森想到了什么答案了吗？ 注意：答案是一个英文句子，以 S （大写）开头，共 5 个词，如果你有不同的答案，但试过不正确，可以微信私信，微信号 Linyunxiang1111，OIer 可以通过 luogu （微信同号）联系。 如果你实在想不出来，我可以给你点提示。 答案是 (n.) (v.) louder than (n.) 的结构。 有 Silence(沉默) 和 words(言语) 一组反义词。 剩下的那个单词是“说”的意思。 记得首字母大写，末尾句点哦！！！！","categories":[],"tags":[{"name":"password","slug":"password","permalink":"https://linlin1195.github.io/tags/password/"}]},{"title":"汶川大地震17周年祭","slug":"汶川地震","date":"2025-05-12T06:28:04.000Z","updated":"2025-05-12T06:28:04.000Z","comments":true,"path":"2025/05/12/汶川地震/","permalink":"https://linlin1195.github.io/2025/05/12/%E6%B1%B6%E5%B7%9D%E5%9C%B0%E9%9C%87/","excerpt":"","text":"汶川大地震17周年祭📅 灾难时刻 ​时间：2008年5月12日14时28分04秒 ​震级：里氏8.0级（汶川地震带） ​伤亡数据： 近7万人遇难 37万余人受伤 1.8万人失踪 数百万人流离失所 🕯️ 永恒记忆生命瞬间 ​教师谭千秋：用身体护住4名学生 ​可乐男孩：被埋80小时后获救的第一句话 ​短信妈妈：废墟中用生命保护婴儿，留下感人遗言 救援壮举 15万解放军72小时挺进所有重灾区 全国调集14.6万医护人员 民间志愿者超300万人次 🌱 灾难启示制度进步 中国应急管理体系全面升级 《防震减灾法》修订（2009） 全国学校/医院抗震标准提高1-2个等级 社会觉醒 首次建立心理援助长效机制 民间组织参与度提升400% 全国捐款捐物总值超760亿元 🏗️ 重生之路 重建领域 成果展示 城乡住房 建成65万套永久性住房 基础设施 修复/新建公路5.1万公里 产业振兴 培育300+特色农业项目 生态修复 完成46万亩地质灾害治理 💡 纪念意义 ​国家记忆日：2009年起每年5月12日为”防灾减灾日” ​精神遗产： 形成”万众一心、众志成城”的抗震精神 建立”对口支援”灾后重建模式 ​国际影响：中国救援队首次获得联合国国际重型救援队认证 “废墟上长出的不仅是新楼，更是一个民族面对灾难的智慧与勇气。” —— 汶川纪念馆题词","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"https://linlin1195.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"P1125-题解","slug":"P1125-题解","date":"2025-05-10T01:04:03.000Z","updated":"2025-05-10T01:04:57.814Z","comments":true,"path":"2025/05/10/P1125-题解/","permalink":"https://linlin1195.github.io/2025/05/10/P1125-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"P1125 笨小猴 题解P1125 in Luogu 题意简化你需要判断一个由小写字母组成的单词是否是“Lucky Word”。 判断方法如下： 统计这个单词中每个字母的出现次数。 找出出现次数最多的字母的出现次数，记作 maxn。 找出出现次数最少的字母的出现次数，记作 minn。 计算差值：diff = maxn - minn 判断这个差值 diff 是否是质数： 如果是质数，则输出 \"Lucky Word\" 和该差值； 如果不是质数，则输出 \"No Answer\" 和 0。 思路本题为模拟题，可以直接按照题目要求写代码，分为三个函数。 maxx 函数：用于计算最多的字母的出现次数。 minn 函数：用于计算最少的字母的出现次数（注意不能是0）。 is_prime 函数：用于计算是否为素数。 maxx 函数可以用桶的思想，每读到1个字母就把他的字母表号加入至桶中。 12345678910111213int maxx(string s){ // 求最多次数 int a[30]; // 桶 memset(a,0,sizeof(a)); // 清零 int len = s.size(); for(int i=0;i&lt;len;i++){ a[s[i]-'a'] ++; // 核心 } int maxa = -1e9; for(int i=1;i&lt;=26;i++){ maxa = max(maxa,a[i]); } return maxa;} minn 函数同理，一定注意不能为0（我因此WA过）！！ 12345678910111213int minn(string s){ // 求最少次数 int a[30]; memset(a,0,sizeof(a)); int len = s.size(); for(int i=0;i&lt;len;i++){ a[s[i]-'a'] ++; } int mina = 1e9; // 赋成极大值 for(int i=1;i&lt;=26;i++){ mina = min(mina,a[i]); } return mina;} is_prime 函数直接用简短的 筛法。 123456789bool is_prime(int n){ // 简短判素 if(n &lt; 2) return false; for(int i=2;i&lt;=sqrt(n);i++){ if(n % i == 0){ return false; } } return true;} AC code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int INF = 0x3fffffff;int maxx(string s){ // 求最多次数 int a[30]; // 桶 memset(a,0,sizeof(a)); // 清零 int len = s.size(); for(int i=0;i&lt;len;i++){ a[s[i]-'a'] ++; } int maxa = -1e9; for(int i=1;i&lt;=26;i++){ maxa = max(maxa,a[i]); } return maxa;}int minn(string s){ // 求最少次数 int a[30]; memset(a,0,sizeof(a)); int len = s.size(); for(int i=0;i&lt;len;i++){ a[s[i]-'a'] ++; } int mina = 1e9; // 赋成极大值 for(int i=1;i&lt;=26;i++){ mina = min(mina,a[i]); } return mina;}bool is_prime(int n){ // 简短判素 if(n &lt; 2) return false; for(int i=2;i&lt;=sqrt(n);i++){ if(n % i == 0){ return false; } } return true;}int main(){ string s; cin &gt;&gt; s; int cnt = maxx(s) - minn(s); if(is_prime(cnt)){ cout &lt;&lt; \"Lucky Word\" &lt;&lt; endl; cout &lt;&lt; cnt &lt;&lt; endl; } else{ cout &lt;&lt; \"No Answer\" &lt;&lt; endl; cout &lt;&lt; 0 &lt;&lt; endl; } return 0;}","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://linlin1195.github.io/tags/C/"}]},{"title":"三体-续写","slug":"三体-续写","date":"2025-05-07T13:26:18.000Z","updated":"2025-05-07T13:29:08.246Z","comments":true,"path":"2025/05/07/三体-续写/","permalink":"https://linlin1195.github.io/2025/05/07/%E4%B8%89%E4%BD%93-%E7%BB%AD%E5%86%99/","excerpt":"","text":"黑暗森林的回声程心站在“星环”号的舷窗前，凝视着那片深邃的宇宙。银河像一条冰冷的锁链，横亘在她与过去之间。自从六年前离开太阳系，人类文明已不再是她所熟悉的那个文明。她知道，自己只是时间长河中的一粒尘埃，而宇宙，则是沉默的巨兽。 她的耳边仿佛还回响着关一帆的声音：“不要相信光速可以被恢复，也不要相信宇宙会自我修复。” 这是他们最后一次见面时说的话。那时，二维化的猎户座悬臂已经逼近，整个世界都在逃亡。程心没有选择进入小宇宙，而是登上了最后一批恒星级曲率飞船之一——“星环”号，带着仅存的人类记忆数据库和一份未解的执念。 她不知道自己是否做错了。 前方是一片死寂的星域，编号NGC-5728。这里曾是一个类星体文明的发源地，如今只剩下残骸与寂静。程心启动了自动探测系统，屏幕上跳动着微弱的信号——那是来自一个古老文明的遗迹，可能藏有关于“归零者”的线索。 归零者，那个试图重启宇宙的组织。他们的广播曾在无数个世纪前传遍银河，呼吁所有文明放弃战争与扩张，回到起点，重新开始。但没人知道他们是否成功，也没有任何文明回应过他们的呼唤。 “也许宇宙真的需要一次重启。”程心轻声说。 突然，警报响起。探测器捕捉到一道微弱却清晰的能量脉冲，频率不属于任何已知文明。程心的心跳加快了。她调出全息投影，那是一段用引力波编码的信息，经过破译后只有一句话： “你不是第一个来这里的。” 这句话让她脊背发凉。她迅速检索数据库，发现“星环”号确实是第一艘抵达NGC-5728的人类飞船。那么，是谁留下了这段信息？ 屏幕上的图像开始变化。一个模糊的身影出现在星空中，像是某种意识体，又像是一个被压缩在四维碎片中的生命。它没有声音，也没有语言，只是静静地注视着程心。那一刻，她感觉自己的意识被拉扯进了一个更深层的空间。 在那里，她看到了一切。 她看到归零者的真正目的并非和平，而是逃避。他们意识到宇宙的熵增不可逆转，于是试图将自身转化为低维度的存在，以延续意识的火种。她看到无数文明在末日边缘挣扎，有的选择自毁，有的选择沉睡，有的则化作黑洞中的涟漪，等待宇宙再次膨胀。 而她，程心，正站在这一切的终点与起点之间。 当她从幻象中醒来，“星环”号的导航系统已经自动锁定一个新的坐标。那是宇宙背景辐射中最冷的一点——大静默区。据说那里没有光，没有物质，只有绝对的虚无。 她按下启动键，飞船缓缓转向那片未知的黑暗。 程心知道，这可能是最后一次航行。但她也明白，真正的希望从来不在光明之中，而在那些敢于面对黑暗的人心中。 （完） （本帖可以评论）","categories":[],"tags":[{"name":"小说","slug":"小说","permalink":"https://linlin1195.github.io/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"最大子段和 题解","slug":"最大字段和 题解","date":"2025-05-05T04:38:34.000Z","updated":"2025-07-03T06:21:24.160Z","comments":true,"path":"2025/05/05/最大字段和 题解/","permalink":"https://linlin1195.github.io/2025/05/05/%E6%9C%80%E5%A4%A7%E5%AD%97%E6%AE%B5%E5%92%8C%20%E9%A2%98%E8%A7%A3/","excerpt":"","text":"luogu P1115 题目简化给出一个长度为 的序列 ，选出其中连续且非空的一段使得这段和最大。 输入 和序列 ，输出一行一个整数表示答案。 对于 的数据，保证 。 对于 的数据，保证 ，。 算法：Algorithm 1 40pts 三层循环枚举左右端点以及区间的和，找出最大字段和，时间复杂度 。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int maxN = 2e5+10;int a[maxN];int main(){ int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++){ cin &gt;&gt; a[i]; } int maxx = -1e9; for(int l=1;l&lt;=n;l++){ for(int r=l;r&lt;=n;r++){ int sum = 0; for(int i=l;i&lt;=r;i++){ sum += a[i]; } maxx = max(maxx,sum); } } cout &lt;&lt; maxx &lt;&lt; endl; return 0;} 期望得分40分。 Algorithm 2 100pts dp，具体过程： 将第一个数成为一个答案序列。 如果下一个数加上上一个答案序列得到的结果比这个数大，那么该数也属于这个答案序列。 如果下一个数加上上一个答案序列得到的结果比这个数小，那么该数单独成为一个答案序列。 如果下一个数加上上一个答案序列得到的结果与这个数相等，那么该数也属于这个答案序列。(因为加和没加没有区别，但加了还有可能继续变大,毕竟是最大子段和。) 动态转移方程： 1f[i] = max(f[i-1]+n[i],n[i]) 时间复杂度自然是 了。 代码： 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6;const int M = -1e6;int n;int a[N],f[N]; // a为数列，f[i]为到i为止它所在答案序列的元素和。int maxf = M;int main(){ cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i]; for(int i=1;i&lt;=n;i++){ f[i] = max(a[i],f[i-1]+a[i]); if(f[i] &gt; maxf) maxf = f[i]; } cout &lt;&lt; maxf &lt;&lt; endl; return 0;} 期望得分100分。 Algorithm 3 100分 我们自然可以想到把上面的答案数组进行优化，因为b[i]只需要b[i-1]来计算，所以可以优化成一个变量。（a就不用说了吧） 代码： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main() { int n; cin &gt;&gt; n; int ans = -1e9; int a,b; for(int i=1; i&lt;=n; i++) { cin &gt;&gt; a; if(i == 1) b = a; else b = max(a,a+b); ans = max(ans,b); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} Algorithm 4 100分 当然，还有三分的解法。时间复杂度 。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;int n,arr[200200];const int minn = -1e9;int rec(int l,int r) { // 分治函数 if (l == r) { // l=r时，直接返回该位置的值 return arr[l]; } int mid = ( l + r ) &gt;&gt; 1; int sum = 0 , ret1 = minn , ret2 = minn; //ret1为[l..mid]区间内包含mid的最大子段和，ret2为[mid+1..r]区间内包含(mid+1)的最大子段和 for( int i = mid ; i &gt;= l ; i-- ) { sum += arr[i]; ret1 = max( ret1 , sum ); } //求出[i..mid]区间最大值 sum = 0; for( int i = mid+1 ; i &lt;= r ; i++ ) { sum += arr[i]; ret2 = max( ret2 , sum ); } //求出[mid+1..r]区间最大值 return max( max( rec( l , mid ) , rec( mid + 1 , r ) ) , ret1 + ret2 ); //返回可能一 可能二 可能三 中的最大值}int main(){ cin &gt;&gt; n; for(int i = 1 ; i &lt;= n ; i++ ) { cin &gt;&gt; arr[i]; } cout &lt;&lt; rec(1,n) &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://linlin1195.github.io/tags/C/"}]},{"title":"投稿","slug":"投稿","date":"2024-10-06T06:56:20.000Z","updated":"2025-05-07T13:27:59.127Z","comments":true,"path":"2024/10/06/投稿/","permalink":"https://linlin1195.github.io/2024/10/06/%E6%8A%95%E7%A8%BF/","excerpt":"","text":"欢迎大家在评论区投稿。 格式： 1234&lt;your name&gt;title(标题): XXXdate(日期): XXXX-XX-XX XX:XX:XX&lt;内容&gt; The end .","categories":[],"tags":[{"name":"站务","slug":"站务","permalink":"https://linlin1195.github.io/tags/%E7%AB%99%E5%8A%A1/"}]},{"title":"本站公约 | Site's Rules","slug":"本站公约","date":"2024-10-05T06:24:48.000Z","updated":"2025-05-05T06:24:48.000Z","comments":true,"path":"2024/10/05/本站公约/","permalink":"https://linlin1195.github.io/2024/10/05/%E6%9C%AC%E7%AB%99%E5%85%AC%E7%BA%A6/","excerpt":"","text":"位置/域名https://linlin1195.github.io/ 帖子不定时更新，但不要着急哦(⊙o⊙)！ 标签说明一篇文章一般有且仅有 1 个标签，可在主站上方“标签”查询。 © linyunxiang1111(linlin1195) × hexo ● All Rights Reserved","categories":[],"tags":[{"name":"站务","slug":"站务","permalink":"https://linlin1195.github.io/tags/%E7%AB%99%E5%8A%A1/"}]},{"title":"CSP-J","slug":"csp-j","date":"2024-10-05T00:44:55.000Z","updated":"2025-05-05T04:29:55.593Z","comments":true,"path":"2024/10/05/csp-j/","permalink":"https://linlin1195.github.io/2024/10/05/csp-j/","excerpt":"","text":"啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 少了 3分！！！！！！！！！！！！！！ 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 (本帖可以评论)","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://linlin1195.github.io/tags/C/"}]},{"title":"本站成立","slug":"本站成立","date":"2024-10-04T08:37:03.000Z","updated":"2025-05-05T04:27:02.383Z","comments":true,"path":"2024/10/04/本站成立/","permalink":"https://linlin1195.github.io/2024/10/04/%E6%9C%AC%E7%AB%99%E6%88%90%E7%AB%8B/","excerpt":"","text":"2024-10-4,本站正式成立。 另外，想问一下，我发布的素数回文数帖无法渲染 Latex，请问要安装什么包？","categories":[],"tags":[{"name":"站务","slug":"站务","permalink":"https://linlin1195.github.io/tags/%E7%AB%99%E5%8A%A1/"}]},{"title":"素数回文数 题解","slug":"素数回文数 题解","date":"2024-10-04T06:12:35.000Z","updated":"2025-05-10T01:05:02.257Z","comments":true,"path":"2024/10/04/素数回文数 题解/","permalink":"https://linlin1195.github.io/2024/10/04/%E7%B4%A0%E6%95%B0%E5%9B%9E%E6%96%87%E6%95%B0%20%E9%A2%98%E8%A7%A3/","excerpt":"","text":"题目描述 Problem Description如果一个数从左边读和右边读都是同一个数，就称为回文数，例如686就是一个回文数。编程求10到1000内所有的既是回文数同时又是素数的自然数。 输入描述 Input Description无。 输出描述 Output Description若干个数，每行一个。 输入输出样例输入样例1 1无 输出样例1 12311101...(省略) 正式开始题解！这道题是个十分简单的枚举题，暴力判素也不会TLE。 先考虑普通做法。 想法是: 从10到1000，循环枚举每一个数，然后判断它是否是素数并且回文如果是，输出。 如何判素?有一个最暴力的想法，从2一直枚举到x-1，判断这个数是否是x的因子。如果是，那么x不是质数。如果枚举完了都没有return出去，那么可以确定x没有其他因子，是素数。另外还有一个需要注意的点，当x小于2时，x也不为质数。 示范代码如下： 1234567bool is_prime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt; x; i++) if (x % i == 0) return false; return true;} 时间复杂度是 的。 能不能更快？ 答案是肯定的。素数是因子只有1和本身，如果x不是素数，则还有其他因子，其中的因子，假如为a，b.其中必有一个大于 ，一个小于 。所以必有一个小于或等于其平方根的因数，那么验证素数时就只需要枚举2到 就可以了。即一个合数一定含有小于它平方根的质因子。 示范代码如下： 1234567bool is_prime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt; x; i++) if (x % i == 0) return false; return true;} 时间复杂度 ，大大滴优秀啊(赞赏) 如何判回文?我们只需要将数字倒序，然后再看是否和原数相等就可以了。 如何把数字倒序? 最简单的想法是: 把数字转string然后再reverse。(接下来又是欢乐的代码环节了) 12345int reverse(int x) { string tostr = to_string(x); reverse(tostr.begin(), tostr.end()); return stoi(tostr);} 相信有了这些，你应该能A了这道题，祝你们成功 但还是在此贴出暴力A码: 1234567891011121314151617181920212223242526#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool is_prime(int x) { if (x &lt; 2) return false; for (int i = 2; i * i &lt; = x; i++) if (x % i == 0) return false; return true;}int reverse(int x) { string tostr = to_string(x); reverse(tostr.begin(), tostr.end()); return stoi(tostr);}int main() { for (int i = 10; i &lt;= 1000; i++) if (is_prime(i) &amp;&amp; reverse(i) == i) cout &lt;&lt; i &lt;&lt; endl; return 0;} 的复杂度用来AC这道题的确绰绰有余。但是我们还是要想: 还能更快吗?没错，还能更快!前置芝士 欧拉筛 欧拉筛(Euler sieve)，又名线性筛法，因其线性的复杂度而得名，用于筛出1~n之间的所有质数。它在埃氏筛法上做了优化，把埃氏筛法 的近似 的复杂度彻底优化为 。原理是让每个数只被它的最小质因子筛一次，而不是像埃氏筛法一样用质数筛一个合数多次。 获取详细信息 在这里给出示例代码: 12345678910void euler_sieve(int n) { not_prime[0] = not_prime[1] = true; for (int i = 2; i &lt;= n; i++) { if (!not_prime[i]) primes[primes_num++] = i; for (int j = 0; j &lt; primes_num &amp;&amp; i * primes[j] &lt;= n; j++) { not_prime[i * primes[j]] = true; if (i % primes[j] == 0) break; } }} 现在，我们就很自然地联想到: 这题可以用欧拉筛来做! 但是这有什么用呢? 不就是把 这一段优化掉了吗? 注意到不能让我们把复杂度化为 的罪魁祸首是: reverse函数! 所以现在重点放在reverse上。 reverse的优化 我们知道，传进reverse函数的值在[10, 1000]之间，只可能是[2, 4]位数。 所以我们可以特判x的位数，分别返回值。 12345int reverse(int x) { if (x &lt; 100) return (x / 10) + (x % 10) * 10; if (x &lt; 1000) return (x / 100) + (x / 10 % 10) * 10 + (x % 10) * 100; return 1;} 接下来，让我们把所有元素结合到一起! 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;bool not_prime[1001];int primes[991];int primes_num = 0;void euler_sieve(int n) { not_prime[0] = not_prime[1] = true; for (int i = 2; i &lt; n; i++) { if (!not_prime[i]) primes[primes_num++] = i; for (int j = 0; j &lt; primes_num &amp;&amp; i * primes[j] &lt;= n; j++) { not_prime[i * primes[j]] = true; if (i % primes[j] == 0) break; } }}int reverse(int x) { if (x &lt; 100) return (x / 10) + (x % 10) * 10; if (x &lt; 1000) return (x / 100) + (x / 10 % 10) * 10 + (x % 10) * 100; return 1;}int main() { euler_sieve(1000); for (int i = 0; i &lt; primes_num; i++) if (primes[i] &gt; 9 &amp;&amp; primes[i] == reverse(primes[i])) cout &lt;&lt; primes[i] &lt;&lt; '\\n'; return 0;}","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://linlin1195.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-12-31T16:00:00.000Z","updated":"2025-05-04T12:54:58.338Z","comments":true,"path":"2024/01/01/hello-world/","permalink":"https://linlin1195.github.io/2024/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"站务","slug":"站务","permalink":"https://linlin1195.github.io/tags/%E7%AB%99%E5%8A%A1/"}]}],"categories":[],"tags":[{"name":"password","slug":"password","permalink":"https://linlin1195.github.io/tags/password/"},{"name":"记录","slug":"记录","permalink":"https://linlin1195.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"C++","slug":"C","permalink":"https://linlin1195.github.io/tags/C/"},{"name":"小说","slug":"小说","permalink":"https://linlin1195.github.io/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"站务","slug":"站务","permalink":"https://linlin1195.github.io/tags/%E7%AB%99%E5%8A%A1/"}]}